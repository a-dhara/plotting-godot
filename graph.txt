extends Node2D

@export var graph_scale: = Vector2(1,1)

@export var values_scene: PackedScene
@onready var plot_timer: Timer = $Plot_Timer

@export var min_x: float = -1
@export var max_x: float = 1
@export var min_y: float = -1
@export var max_y: float = 1

@onready var e_x: float = get_viewport().size.x * 0.95
@onready var e_y: float = get_viewport().size.y * 0.95


func linspace(init, end, step):
	var list: = []
	var num = init
	for i in range(int(abs(init-end)/step)+1):
		list.append(num)
		num += step
	return list

@export var x_list: PackedFloat32Array = linspace(0, 6*PI, 0.005)

@export var delta_t: float = 0.005
@export var t_list: PackedFloat32Array = linspace(0, 10, delta_t)

func function_x(x: PackedFloat32Array) -> Array:
	var ans: Array = []
	for xi in x:
#		ans.append(2*exp(-xi/2)*cos(3*xi))
		ans.append(cos(xi)-sin(2*xi))
	return ans

func function_x_t(x: PackedFloat32Array, t: float) -> Array:
	var ans: Array = []
	for xi in x:
		ans.append(cos(xi - 0.1*t))
	return ans

func create_curve(x_l, y_l) -> PackedVector2Array:
	var curve: PackedVector2Array
	
	if len(x_l) != len(y_l):
		print("Different size arrays!")
		return []
	
	for i in range(len(x_l)):
		curve.append(Vector2(x_l[i],y_l[i]))
	
	return curve

func magnit(a: float) ->int:
	return int(log(abs(a))/log(10))

func get_delta(Delta: float) -> float:
	var scales: Array = [1,2,5,10,20,50,100,200,500,1000]
	var ord: float = 10.**(magnit(Delta)-1) #Magnitude order for the minimum x interval
	var delta: float = 1 * ord #delta_x
	var n: int = Delta/delta
	var i: int = 1
	while n> 8:
		delta = scales[i] * ord
		n = Delta/delta
		i += 1
	return delta

func get_new_min(min, delta) -> float:
	var nm = (int(min/delta)) * delta
	if min < 0:
		nm = nm - delta
	return nm

func get_subline_vecs(x, dir, translation) ->PackedVector2Array:
	var line_length: = 0.01*e_x
	var vectors: Array
	if dir == "x":
		vectors = [Vector2(x,-line_length+translation.y),Vector2(x,line_length+translation.y)]
	else:
		vectors = [Vector2(-line_length+translation.x,x),Vector2(line_length+translation.x,x)]
	return PackedVector2Array(vectors)

func translate_graph(x_min, x_max, y_min, y_max, dx, dy):
	var trans: = Vector2(20-x_min, 720-(20-y_min))
	position.x = trans.x
	position.y = trans.y
	var axis_translation = Vector2(0,0)
	if x_min > 0:
		axis_translation.x = (x_min + 20)
	elif x_max < 0:
		axis_translation.x = (x_max - 20)
	if y_min > 0:
		axis_translation.y = (y_min + 20)
	elif y_max < 0:
		axis_translation.y = (y_max - 20)
	
	
	return [trans, axis_translation]

func print_axis_values(pos: Vector2, translation:Array, dir: String, scale_d: float):
	var val = values_scene.instantiate()
	var correction = 5 * Vector2(1,1)
	if dir == "x":
		val.position = pos * scale_d + correction + translation[0]
		val.position.y -= translation[1].y
		val.get_child(0).text = str(pos.x)
		get_parent().add_child(val)
	elif dir == "y":
		val.position = pos * scale.y * scale_d + correction + translation[0]
		val.position.x += translation[1].x
		val.get_child(0).text = str(pos.y)
		get_parent().add_child(val)
	pass

func axis(x_min,x_max,y_min,y_max,scale_v):
	
	var delta_x = get_delta(abs(x_max - x_min)/scale_v.x)
	var delta_y = get_delta(abs(y_max - y_min)/scale_v.y)
	var new_min = Vector2(get_new_min(x_min/scale_v.x,delta_x), get_new_min(y_min/scale_v.y, delta_y))
	var translate = translate_graph(x_min, x_max, y_min, y_max, delta_x, delta_y)
	
	for j in range(abs(x_max - x_min)/(delta_x*scale_v.x) + 2):
		draw_polyline(get_subline_vecs(new_min.x*scale_v.x + delta_x * scale_v.x * j, "x", translate[1]), Color.BLACK, 0.002*e_x) #x sublines
		print_axis_values(Vector2(new_min.x + delta_x * j, 0), translate, "x", scale_v.x)
	
	for j in range(abs(y_max - y_min)/(delta_y*scale_v.y) + 2):
		draw_polyline(get_subline_vecs(new_min.y*scale_v.y + delta_y * scale_v.y * j, "y", translate[1]), Color.BLACK, 0.002*e_x) #y sublines
		print_axis_values(Vector2(0,new_min.y + delta_y * j), translate, "y", scale_v.y)
	
	var x_line = PackedVector2Array([Vector2(x_min, translate[1].y),Vector2(x_max, translate[1].y)])
	var y_line = PackedVector2Array([Vector2(translate[1].x, y_min),Vector2(translate[1].x, y_max)])
	draw_polyline(x_line, Color.BLACK, 0.003*e_x) #x axis line
	draw_polyline(y_line, Color.BLACK, 0.003*e_x) #y axis line
	
	return


func plot(x_l, y_l) -> void: #Plot a y(x) function along x_l
	min_x = Array(x_l).min()
	max_x = Array(x_l).max()
	min_y = Array(y_l).min()
	max_y = Array(y_l).max()
	var scale_vec = Vector2(e_x/abs(max_x - min_x), e_y/abs(max_y - min_y))
	
	for i in range(len(x_l)):
		x_l[i] = x_l[i] * scale_vec.x
		y_l[i] = y_l[i] * scale_vec.y
	min_x = Array(x_l).min()
	max_x = Array(x_l).max()
	min_y = Array(y_l).min()
	max_y = Array(y_l).max()
	
	draw_polyline(create_curve(x_l, y_l), Color.ROYAL_BLUE, 0.008*e_y)
	axis(min_x, max_x, min_y, max_y, scale_vec)
	pass


func animated_plot(x_l, t_l) -> void: #Plot a y(x,t) along x_l varying t alog t_l
	plot_timer.wait_time = delta_t
	var count: int = 0
	plot_timer.timeout.connect(func():
		print(count)
		plot(x_l, function_x_t(x_l, t_l[count]))
		count += 1
		if count == len(t_l):
			count = 0
		)
	pass

func _draw() -> void:
#	plot(x_list, function_x(x_list))
	animated_plot(x_list, t_list)
#	pacman()

func pacman() -> void:
	draw_arc(Vector2(500,300), 100, deg_to_rad(20), deg_to_rad(360-20), 50, Color.YELLOW, 200)
